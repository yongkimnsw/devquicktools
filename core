#!/bin/bash

text_red=$(tput setaf 1)
text_green=$(tput setaf 2)
text_blue=$(tput setaf 4)
text_magenta=$(tput setaf 5)
text_yellow=$(tput setaf 3)
text_bold=$(tput bold)
text_rev=$(tput rev)
text_reset=$(tput sgr0)

sed_remove_index() {
    sed -r 's/^[[:space:]]*[0-9]+[[:space:]]+//g'
}

sed_exclude_0_index() {
    sed -r "/^[[:space:]]*0[[:space:]]+/d"
}

smart_pwd() {
    echo "$PWD" | sed -r "s#^$HOME($|/)#~\1#g"
}

smart_pwd_escaped() {
    smart_pwd | sed -r 's/\(/\\(/g;s/\)/\\)/g;'
}

smart_popd() {
    for i in $(dirs -v | sort -rn -k 1 | sed -rn "s#^[[:space:]]*([1-9]+[0-9]*)[[:space:]]+$(smart_pwd_escaped)\$#\1#p"); do
        popd -n "+$i" > /dev/null
    done
}

sed_pushd() {
    sed -rn 's#(.*)#pushd -n "\1" > /dev/null#p'
}

smart_history_update() {
    # push current directory
    smart_popd
    pushd -n "$(smart_pwd)" > /dev/null

    # merge memory history into stored history
    (dirs -v | sed_remove_index; cat ~/.dirstack 2> /dev/null;) | sort -ur > ~/.dirstack.$$
    mv -f ~/.dirstack.$$ ~/.dirstack

    # load stored history
    dirs -c
    source <( cat ~/.dirstack 2> /dev/null | sed_pushd)
}

smart_history_show() {

    echo ""
    dirs -v | sed_exclude_0_index | sed -r 's/^ ([0-9] )/\1  /g;s/^([0-9][0-9] )/\1 /g;' | sed -rn "s#^([[:space:]]*)([1-9]+[0-9]*)([[:space:]]+)(.*)\$#\1\2\3\4 [\2]#p;" | sort -u -k 2 |
        sed -r "s#^([[:space:]]*[0-9]+[[:space:]]+$(smart_pwd_escaped)[[:space:]]+\[[0-9]+\])\$#$text_magenta\1*$text_reset#g;"

    echo ""
}

smart_seq() {
    eval $(
        sed -rn '
            /^([0-9]+)-([0-9]+)$/ {
                s/^([0-9]+)-([0-9]+)$/seq \1 \2;/p
            }

            /^([0-9]+)$/ {
                s/^([0-9]+)$/echo \1;/p
            }
        '
    )
}

egrep_pwd() {
    _pwd=$(smart_pwd_escaped)
    egrep "$@" "^[[:space:]]*[0-9]+[[:space:]]+${_pwd}\$"
}

dirsv_without_0_index() {
    dirs -v | sed_exclude_0_index | egrep_pwd -v
}

sed_dir_only() {
    head -n 1 | sed -rn "s#^([[:space:]]*)([1-9]+[0-9]*)([[:space:]]+)(.*)\$#\4#p;"
}

print_parent_dirs() {
    (
        smart_pwd
        while true; do
            if [ "x$PWD" = "x/" ]; then
                break
            fi

            cd .. 2> /dev/null
            smart_pwd
        done
    )
}

find_mlocate_db() {
    (
        while [ ! -f "mlocate.db" ]; do
            if [ "x$PWD" = "x/" ]; then
                break
            fi

            cd .. 2> /dev/null
        done

        if [ -f "mlocate.db" ]; then
            echo "$PWD/mlocate.db"
        else
            echo "mlocate.db not found" >&2
        fi
    )
}

xargs_md5sum() {
    xargs -r md5sum  2> /dev/null | sort --parallel=8
}


highlight() {
    ag --passthru "$*"
}

search_mlocate_db() {
    if [ "x$mlocate_db" = "x" ]; then
            echo "mlocate.db not found" >&2
    else
        locate -d "$mlocate_db" "$@"
    fi
}

print_mlocate_info() {
    if [ -t 1 ]; then
        echo "$text_magenta== [find subdirectory] $mlocate_db ==$text_reset"
    fi
}

print_sep() {
    msg="$*"
    printf "$text_bold%-200s$text_reset\n" "${msg:+[ $msg ]}" | sed -r 's/  /==/g;s/= /==/g;'
}


print_mlocate_ignore() {
    sed -r \
            "
                s%#.*%%g;
                /^[[:space:]]*$/d;
                s%^([^/\\.])%$mlocate_dir\\1%g;
                s%^\\./%$mlocate_dir/%g;
                s%/$%%g;
            " \
        "$mlocate_ignore" 2> /dev/null
}

grep_pwd_and_remove() {
    local dir_to_remove="$1"
    grep "^$dir_to_remove/" | sed -ru "s%^$dir_to_remove/(.*)%./\1%g"
}

# search locate database
command_tf() {

    local pipe_command1="cat"
    local pipe_command2="cat"

    while [ $# -gt 0 ]; do
        case $1 in
            -f)
                shift
                pipe_command1="grep_pwd_and_remove ${PWD}"
                ;;

            -m)
                shift
                pipe_command2="xargs_md5sum"
                ;;

            *)
                break
                ;;
        esac
    done

    mlocate_db=$(find_mlocate_db 2> /dev/null)
    search_mlocate_db -r "$*" | $pipe_command1 | $pipe_command2 | highlight "^.*/rootfs|/rootfs|$*"
}


# build locate database
command_b() {
    local mlocate_db
    if [ "$#" -gt 0 ]; then
        mlocate_db="$1/mlocate.db"
    else
        mlocate_db=$(find_mlocate_db)
    fi

    test -n "$mlocate_db" || return 1

    echo "$text_magenta== [start collecting   ] $mlocate_db ==$text_reset"

    mlocate_dir="$(dirname "$mlocate_db")"
    mlocate_ignore="$mlocate_dir/.mlocateignore"

    exclude_options="$(print_mlocate_ignore | sed -rn 's/^(.+)$/-e \1/p')"
    updatedb -l 0 -o "$mlocate_db" -U "$mlocate_dir" $exclude_options && echo "$text_magenta== [finished collecting] $mlocate_db ==$text_reset" >&2
}

command_p() {
    local clipboard
    if [ $# -lt 1 ]; then
        clipboard=$(pwd | tr -d '\n')
        echo -n "$clipboard" | xsel --clipboard -i
    else
        clipboard=$(readlink -f "$@" | tr -d '\n')
        echo -n "$clipboard" | xsel --clipboard -i
    fi
    echo "$clipboard"
}


command_u() {
    dirs -c
    smart_history_update
}

command_s() {
    [ "$#" = 0 ] || cd "$@"
    print_sep ""
    echo "directory : $(pwd)"
    if svn info > /dev/null 2> /dev/null; then
        print_sep "SVN info"
        svn info
        print_sep "SVN log"
        svn log -l 3
        print_sep "SVN status"
        svn status
        print_sep ""
    elif git status > /dev/null 2> /dev/null; then
        print_sep "GIT tag"
        git --no-pager tag -l
        print_sep "GIT branch (remote)"
        git --no-pager branch -rv
        print_sep "GIT remote"
        git --no-pager remote -v
        print_sep "GIT log"
        git --no-pager log -n 3
        print_sep "GIT branch (local)"
        git --no-pager branch -v
        print_sep "GIT status"
        git --no-pager status
        print_sep ""
    else
        print_sep ""
        echo "No source control found"
        print_sep ""
    fi
}

command_c() {
    cdir=""
    if [ "$#" -eq 0 ]; then
        #smart_wcd . > /dev/null
        smart_history_show
        return 0
    elif [ "x$1" = "x!" ]; then
        shift

        rm -f ~/.dirstack*

        if [ "$#" -eq 0 ]; then
            dirs -c
        else
            re='(^[0-9]+$|^[0-9]+-[0-9]+$)'
            for j in "$@"; do

                if [[ "$j" =~ $re ]]; then
                    for i in $(echo "$j" | tr ' ' '\n'| smart_seq | sort -rn); do
                        echo "delete $(dirs +$i)"
                        popd -n "+$i" > /dev/null
                    done
                else
                    for i in $(dirsv_without_0_index | egrep "$j" | sed -rn 's/^[[:space:]]*([0-9]+).*/\1/p' | sort -rn); do
                        echo "delete $(dirs +$i)"
                        popd -n "+$i" > /dev/null
                    done
                fi
            done
        fi

        smart_history_update
        return 0

    elif [ -e "$1" ] && [ ! -d "$1" ]; then
        eval /usr/bin/wcd.exec -i -q -c $(dirname "$1") || return $?
    else
        if [ "$1" = '=' -o "$1" = '-' -o "$1" = '+' -o "${1}" = ".." -o "${1}" = "." ]; then
            cdir="$1"
        elif (cd "$@") 2> /dev/null; then
            sdir=""
        else
            sdir=""
            test -n "$sdir" || sdir=$(dirsv_without_0_index | egrep -i "^[[:space:]]*$*[[:space:]]+" | sed_dir_only)

            while read i; do
                test -n "$sdir" || sdir=$(dirsv_without_0_index | egrep -i "$i/.*/$*$" | sed_dir_only)
                test -n "$sdir" || sdir=$(dirsv_without_0_index | egrep -i "$i/.*/$*" | sed_dir_only)
                test -n "$sdir" || sdir=$(dirsv_without_0_index | egrep -i "$i/.*$*" | sed_dir_only)
            done < <(print_parent_dirs)

            test -n "$sdir" || sdir=$(dirsv_without_0_index | egrep -i "/$*$" | sed_dir_only)
            test -n "$sdir" || sdir=$(dirsv_without_0_index | egrep -i "/$*" | sed_dir_only)
            test -n "$sdir" || sdir=$(dirsv_without_0_index | egrep -i "$*" | sed_dir_only)
        fi

        sdir=${sdir/#~\//$HOME\/}

        if [ -z "$cdir" ]; then
            /usr/bin/wcd.exec -i -q -c "${sdir:-$*}" || return $?
        fi
    fi

    if [ -z "$cdir" ]; then
        grep -q "cd" ~/bin/wcd.go 2> /dev/null || return $?
        source ~/bin/wcd.go || return $?
    else
        cd "$cdir"
    fi

    if [ -t 1 ]; then
        smart_history_update
        echo "$text_magenta== [cd] $(dirs -v | sed_exclude_0_index | egrep_pwd | sed -rn "s#^([[:space:]]*)([1-9]+[0-9]*)([[:space:]]+)(.*)\$#\1\2\3\4 [\2]#p;") ==$text_reset"
    fi

    #echo -ne "\033]30;$(basename $(pwd))\007"

    return $?
}

command_a() {
    ag --hidden -U --ignore-dir .git --ignore-dir .svn "$@"
}

command_ge() {
    if [ "$#" -gt 0 ]; then

        ls -d */.git 2> /dev/null | while read i; do
            echo "$text_bold========== ${i%/.git}$text_reset"
            git -C "${i%/.git}" "$@"
        done
    else
        echo "git-foreach <git parameters>..." >&2
    fi
}

bail() {
    echo "$*" >&1
}

command_q() {
    local dcommand="$(dirname "$fcommand")"

    case "$1" in
        install)
            for i in a b c ge p s u t tm f fm; do
                ln -s "$dcommand/core" -T "$i" || bail "failed to install $i"
            done
            ;;

        uninstall)
            for i in a b c ge p s u t tm f fm; do
                ofile="$(readlink -f "$i")"
                bname="$(basename -- "$ofile")"

                [ "xcore" = "x$bname" ] || bail "failed to uninstall $i"
                rm $i
            done
            ;;

        help|*)
            print_usage
            ;;
    esac
}

# bash settings
set -o vi

# alias
alias clipboard="xsel --clipboard"
alias a=""
alias mc='source /usr/lib/mc/mc-wrapper.sh --nomouse'
alias fd='fdfind -IHp'

# editors
export SVN_EDITOR=vi
export VISUAL=vim
export EDITOR="$VISUAL"

PS1='[${debian_chroot:+($debian_chroot)}\[\033[01;34m\]\W\[\033[00m\]]\$ '


print_usage() {
    cat << EOF

devquicktools v1.0 <command> [options]

commnads)

    * locale database
        b [dir]
            build locate database

        t[m] [regex] : search locate database for files and directories.
            options)
                m       md5sum
                regex   regular expression to match files or directories.

        f[m] [regex] : search locate database for files and directories in PWD and its children.
            options)
                m       md5sum
                regex   regular expression to match files or directories.

    * directories
        p [file]    : copy the full path of file (or PWD) into clipboard
        c [regex]   : do smart CD
        u           : read directory history from disk.

    * text search
        a : ag

    * version control utilities
        s                   : get state of SVN or GIT
        ge <git options>    : git for each directory

    * misc
        install     : install quick commands
        uninstall   : uninstall quick commands
        help        : help
EOF

}

# parse command
fcommand="$0"
command=$(basename -- "$fcommand")

# use the first argument if core is used
if [ "x$command" = "xcore" ]; then
    subcommand="q"
    shift
else
    subcommand="$command"
fi

# parse subcommand
case "$subcommand" in
    t)
        command_tf "$@"
        ;;

    tm)
        command_tf -m "$@"
        ;;

    f)
        command_tf -f "$@"
        ;;

    fm)
        command_tf -f -m "$@"
        ;;

    a|b|c|ge|p|s|u|q)
        "command_$subcommand" "$@"
        ;;

esac
